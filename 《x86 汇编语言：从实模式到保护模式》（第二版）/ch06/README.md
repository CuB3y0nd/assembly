## 检测点 6.1

```
在我们日常使用的个人计算机上，在文本模式下的显示缓冲区被映射到物理内存地址空间，起始地址为（），它对应的段地址为（）。在标准的 80x25 文本模式下，要想在屏幕右下角显示一个绿底白字的字符「H」，那么，应当在该段内偏移量为（）的地方开始，连续写入 2 字节（）和（）。
```

- `0xb8000`、`0xb800`、`0xf9e`、`0x48`、`0x27`

$$
\begin{aligned}
& \text{由于每个字符需要两个字节来显示，所以在 80x25 文本模式下，单屏可以显示 ${80}\times{25}={2000}$ 个字符，共用 4000 Bytes。} \\
& \text{因此，要在屏幕右下角显示一个字符就要从偏移地址 0xf9e 处开始写入字符。}
\end{aligned}
$$

```
以下指令，哪些是不正确的，不正确的原因是什么？

A. mov al, 0x55aa        B. mov ds, 0x6000        C. mov ds, al
D. mov [0x06], 0x55aa    E. mov ds, bx            F. mov ax, 0x02
G. mov word [0x0a], ax   H. mov es, cx            I. mov ax, bl
J. mov byte [0x00], 'c'  K. mov [0x02], [0xf000]  L. mov ds, [0x03]
```

- $\text{A：将一个 16-bit 的立即数传送到一个 8-bit 的寄存器}$
- $\text{B：将一个立即数传送给段寄存器}$
- $\text{C：数据宽度不同}$
- $\text{D：0x55aa 既可以按照 16-bit(word) 操作，也可以按照 32-bit(dword) 操作}$
- $\text{I：数据宽度不同}$
- $\text{K：内存单元之间不能执行传送指令}$

## 检测点 6.2

```
找出下面代码片段中的错误。用 Nasmide 程序实际编译一下，看看结果如何。

data1 db 0x55, 0xf000, 0x0f
data2 dw 0x38, 0x20, 0x55aa
```

- `data1` 中的 `db` 只能声明字节大小的数据，却包含了 `0xf000` 这样的字数据

## 检测点 6.3

```
INTEL x86 处理器访问内存时，是按低端字节序进行的。那么，以下程序片段执行后，寄存器 AX 中的内容是多少？

mov word [data], 0x2008
xor byte [data], 0x05
add word [data], 0x0101
mov ax, [data]

data db 0, 0
```

- $\text{寄存器 AX 中的内容是 0x210e}$

```
对于以上程序片段，如果标号 data 在编译时的汇编地址是 0x0030，那么，当该程序加载到内存后，该程序片段所在段的地址为 0x9020 时，该标号处的段内偏移地址和物理内存地址各是多少？
```

- $\text{段内偏移地址为 0x0030，物理地址为 0x90230}$

```
对于以下指令的写法，说出哪些是正确的，哪些是错误的，错误的原因是什么。

A. mov ax, [data1]   B. div [data1]      C. xor ax, dx
D. div byte [data2]  E. xor al, [data3]  F. add [data4], 0x05
G. xor 0xff, 0x55    H. add 0x06, al     I. div 0xf0
J. add ax, cl
```

- $\text{B：没有指定操作大小}$
- $\text{F：没有指定操作大小}$
- $\text{G：xor 的目的操作数只能是通用寄存器或内存单元}$
- $\text{H：add 的目的操作数不能是立即数}$
- $\text{I：div 的操作数只能是通用寄存器或内存单元}$
- $\text{J：数据宽度不匹配}$

```
如果寄存器 AX、寄存器 BX和寄存器 DX 的内容分别为 0x0090、0x9000 和 0x0001，那么，执行 div bh 后，这三个寄存器的内容各是多少？执行 div bx 后呢？
```

- $\text{执行 div bh 后，这三个寄存器的内容分别是：0x0001、0x9000、0x0001}$
- $\text{执行 div bx 后，这三个寄存器的内容分别是：0x0001、0x9000、0x7090}$

## 检测点 6.4

```
写出以下程序片段中的那两条 jmp 指令的机器指令吗，并在 Nasmide 中编译，验证你的答案是否正确：

jmp near start
data db 0x55, 0xaa
start: mov ax, 0
jmp 0x2000:0x0005
```

- $\text{E9 02 00}$
- $\text{EA 05 00 00 20}$

## 检测点 6.5

```
1. 在你的计算机上重现以上的编译、运行（使用 VirtualBox）和调试（使用 bochsdbg）过程。
2. 单步执行本章程序，观察 div 指令执行后的寄存器内容变化。
```

- 略

## 第 6 章习题

```
找出以下程序片段中隐藏的问题并进行修正：

mov ax, 21015
mov bl, 10
div bl
and cl, 0xf0
```

- $\text{寄存器 AL 的大小 (0xFF) 容不下商的值 (0x8449)。下面为修正后的代码：}$

```nasm
mov ax, 21015
xor dx, dx
mov bx, 10
div bx
and cl, 0xf0
```

```
本章的程序在内存中的加载地址是 0x0000:0x7C00，此时，指令 jmp near infi 在段内的偏移地址是多少？试修改本章的源程序以显示该值。
```

- $\text{0x12b}$

```
汇编语言编译器采用助记符来方便指令的书写和阅读，而且在内存里，机器指令以数字的形式存在。比如，mov 是传送指令，div 是除法指令。假如 INTEL 公司新推出一款处理器，该处理器新增加了一条指令，其机器码为 2 字节的 0xCD 0x88。因为是新指令，所以你的 NASM 编译器肯定没有一个助记符与之相对应。在这种情况下，如何在你的程序中使用该指令？
```

- $\text{db 0xcd 0x88}$
