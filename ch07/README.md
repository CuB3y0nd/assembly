## 检测点 7.1

```
选择填空：movsb 指令每次传送一（），movsw 指令每次传送一个（）。原始数据在段内的偏移地址在寄存器（）中，要传送的目标位置的偏移地址在寄存器（）中。如果要连续传送多个字或字节，则需要（）前缀，在寄存器（）中设置传送的次数，并设置传送的方向。其中，（）指令指示正向传送，（）指令指示反向传送。反向传送时，每传送一次，SI 和 DI 的内容将（）。

A. 字节  B. 字  C. DI  D. SI  E. CX  F. rep  G. 减小  H. std  I. cld  J. 增大
```

 - $\text{A、B、D、C、F、E、I、H、G}$

## 检测点 7.2

```
选择题：下面哪些指令是错误的，为什么？

A. add ax, [bx]  B. mov ax, [si]   C. mov ax, [cx]   D. mov dx, [di]
E. mov dx, [ax]  F. inc byte [di]  G. div word [bx]
```

 - $\text{C、E：在 8086 处理器上，如果要用寄存器来提供偏移地址，只能使用寄存器 BX、SI、DI、BP。}$

## 检测点 7.3

```
假如以下声明的是有符号数，那么，其中的负数是（）。

data0 db 0xf0, 0x05, 0x66, 0xff, 0x81
data1 dw 0xfff, 0xffff, 0x8b, 0x8a08
```

 - $\text{0xf0、0xff、0x81、0xffff、0x8a08}$

## 检测点 7.4

```
ZF 标志位和与该标志位有关的条件转移指令用得非常频繁，但很多人容易在 ZF 标志位上犯糊涂，以为计算结果为零时，ZF 为「0」。为了证明你不糊涂，请填空：当 ZF=( ) 时，表明计算结果为零；jz 指令的意思是当 ZF=( )，即计算结果为 ( ) 时转移；je 指令的意思是当 ZF=( )，即计算结果为 ( ) 时转移；jnz 指令的意思是当 ZF=( )，即计算结果不为 ( ) 时转移；jne 指令的意思是当 ZF=( )，即计算结果不为 ( ) 时转移。
```

 - $\text{1、1、0、1、0、0、0、0、0}$

```
写一段小程序，先比较寄存器 AX 和 BX 中的数值，然后，当 AX 的内容大于 BX 的内容时，转移到标号 lbb 处执行；AX 的内容等于 BX 的内容时，转移到标号 lbz 处执行；AX 的内容小于 BX 的内容时，转移到标号 lbl 处执行。
```

```nasm
cmp AX, BX
ja lbb
je lbz
jl lbl
```

