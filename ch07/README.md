## 检测点 7.1

```
选择填空：movsb 指令每次传送一（），movsw 指令每次传送一个（）。原始数据在段内的偏移地址在寄存器（）中，要传送的目标位置的偏移地址在寄存器（）中。如果要连续传送多个字或字节，则需要（）前缀，在寄存器（）中设置传送的次数，并设置传送的方向。其中，（）指令指示正向传送，（）指令指示反向传送。反向传送时，每传送一次，SI 和 DI 的内容将（）。

A. 字节  B. 字  C. DI  D. SI  E. CX  F. rep  G. 减小  H. std  I. cld  J. 增大
```

 - $\text{A、B、D、C、F、E、I、H、G}$

## 检测点 7.2

```
选择题：下面哪些指令是错误的，为什么？

A. add ax, [bx]  B. mov ax, [si]   C. mov ax, [cx]   D. mov dx, [di]
E. mov dx, [ax]  F. inc byte [di]  G. div word [bx]
```

 - $\text{C、E：在 8086 处理器上，如果要用寄存器来提供偏移地址，只能使用寄存器 BX、SI、DI、BP。}$

## 检测点 7.3

```
假如以下声明的是有符号数，那么，其中的负数是（）。

data0 db 0xf0, 0x05, 0x66, 0xff, 0x81
data1 dw 0xfff, 0xffff, 0x8b, 0x8a08
```

 - $\text{0xf0、0xff、0x81、0xffff、0x8a08}$

## 检测点 7.4

```
ZF 标志位和与该标志位有关的条件转移指令用得非常频繁，但很多人容易在 ZF 标志位上犯糊涂，以为计算结果为零时，ZF 为「0」。为了证明你不糊涂，请填空：当 ZF=( ) 时，表明计算结果为零；jz 指令的意思是当 ZF=( )，即计算结果为 ( ) 时转移；je 指令的意思是当 ZF=( )，即计算结果为 ( ) 时转移；jnz 指令的意思是当 ZF=( )，即计算结果不为 ( ) 时转移；jne 指令的意思是当 ZF=( )，即计算结果不为 ( ) 时转移。
```

 - $\text{1、1、0、1、0、0、0、0、0}$

```
写一段小程序，先比较寄存器 AX 和 BX 中的数值，然后，当 AX 的内容大于 BX 的内容时，转移到标号 lbb 处执行；AX 的内容等于 BX 的内容时，转移到标号 lbz 处执行；AX 的内容小于 BX 的内容时，转移到标号 lbl 处执行。
```

```nasm
cmp ax, bx
ja lbb
je lbz
jl lbl
```

## 检测点 7.5

```
调试本章程序。要求：使用反汇编命令定位到源程序第 53 行 (jmp near $)，然后在这里设置断点，并用「c」命令连续执行到该断点位置。注意，Bochs 会把非指令的数据也视为指令，这将有可能导致反汇编不正确。因此，要小心避开这些数据区，在 Bochs 把物理地址 0x7c00 之后的数据（一大堆零）也反汇编成指令时，不要感到惊讶。
```

 - $\text{略}$

## 第 7 章习题

```
在某程序中声明和初始化了以下的有符号数据。请问，正数和负数各有多少？

data1 db 0x05, 0xff, 0x80, 0xf0, 0x97, 0x30
data2 dw 0x90, 0xfff0, 0xa0, 0x1235, 0x2f, 0xc0, 0xc5bc
```

 - $\text{正数：7 个}$
 - $\text{负数：6 个}$

```
如果可能的话，尝试编写一个主引导扇区程序来做上面的工作。
```

 - 还没写呢，写完上传 >_<

```
请问下面的循环将执行多少次：

mov cx, 0
delay: loop delay
```

 - $\text{65536 次}$

$$
\begin{aligned}
& \text{CX 减 1，此时 CX = ··· (1111 1111 1111 1111 1111)$\_{B}$，loop 判断 CX 不为 0，跳转到 delay 处继续执行。} \\
& \text{CX 再次减 1，此时 CX = ··· (1111 1111 1111 1111 1110)$\_{B}$，loop 判断 CX 不为 0，跳转到 delay 处继续执行。} \\
& \text{CX 再次减 1，此时…} \\
& \text{CX 持续减 1，直到 CX = ··· (1111 0000 0000 0000 0000)$\_{B}$ 时，CX 为 0，loop 判断 CX 为 0，跳出循环。} \\
& \text{一直到 CX = ··· (1111 0000 0000 0000 0000)$\_{B}$ 为止，一共执行了 (1111 1111 1111 1111)$\_{B}$ + (1)$\_{B}$ = (65535)$\_{D}$ + (1)$\_{D}$ = (65536)$\_{D}$ 次。}
\end{aligned}
$$
 
